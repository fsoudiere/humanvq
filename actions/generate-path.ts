"use server"

import { createClient } from "@/utils/supabase/server"
import { revalidatePath } from "next/cache"
import OpenAI from "openai"
import { ensureProfile } from "@/actions/profiles"
import { calculatePathHVQScore } from "@/actions/path-resources"

const openai = new OpenAI({
  apiKey: process.env.OPENAI_API_KEY,
})

export interface GeneratePathInput {
  currentRole: string
  bioContext: string
  mainGoal: string
}

export interface GeneratePathResult {
  success: boolean
  error?: string
  pathId?: string
}

export async function generatePath(
  data: GeneratePathInput
): Promise<GeneratePathResult> {
  try {
    const supabase = await createClient()

    // 1. Ensure profile exists with username (includes auth verification and retry logic)
    const profileResult = await ensureProfile()
    if (!profileResult.success) {
      return { success: false, error: profileResult.error || "Failed to ensure profile" }
    }

    // 2. Get authenticated user for path creation
    const { data: { user }, error: userError } = await supabase.auth.getUser()
    if (userError || !user) {
      return { success: false, error: "User not authenticated" }
    }

    // 2. Create a new path record with slug = null and 'Untitled Path' title
    // The slug will be generated by n8n webhook when path_title is provided
    const { data: newPath, error: pathCreateError } = await supabase
      .from("upgrade_paths")
      .insert({
        user_id: user.id,
        role: data.currentRole,
        main_goal: data.mainGoal,
        context: data.bioContext,
        path_title: "Untitled Path", // Initial placeholder title
        slug: null, // Slug will be set by n8n webhook when path_title is ready
        efficiency_audit: null,
        ai_tools: null,
        human_courses: null,
        immediate_steps: null,
      })
      .select("id")
      .single()

    if (pathCreateError || !newPath) {
      return { success: false, error: "Failed to create path" }
    }

    const pathId = newPath.id

    // Fetch the path record to use its data for matching
    const { data: pathRecord, error: pathFetchError } = await supabase
      .from("upgrade_paths")
      .select("role, main_goal, context, primary_pillar")
      .eq("id", pathId)
      .single()

    if (pathFetchError || !pathRecord) {
      return { success: false, error: "Failed to fetch path record" }
    }

    // =========================================================
    // ðŸ§  DATABASE MATCHING (FILTERS ENABLED)
    // =========================================================
    let verifiedTools: any[] = []
    let verifiedCourses: any[] = []

    try {
      // Use the path record's data for embedding (role, main_goal, context from upgrade_paths)
      const embeddingInput = `${pathRecord.role} ${pathRecord.main_goal} ${pathRecord.context}`

      const embeddingResponse = await openai.embeddings.create({
        model: "text-embedding-3-small",
        input: embeddingInput,
      })
      const userVector = embeddingResponse.data[0].embedding

      // SEARCH TOOLS (Strict Filter: ai_tool)
      const { data: tools, error: toolError } = await supabase.rpc("match_resources", {
        query_embedding: userVector,
        match_threshold: 0.1, // Keep this low to ensure matches
        match_count: 6,       // Get top 6
        filter_type: "ai_tool",
        target_pillar: pathRecord.primary_pillar || null
      })

      if (toolError) {
        verifiedTools = []
      } else if (tools && Array.isArray(tools)) {
        verifiedTools = tools
      } else {
        verifiedTools = []
      }

      // SEARCH COURSES (Strict Filter: human_course)
      const { data: courses, error: courseError } = await supabase.rpc("match_resources", {
        query_embedding: userVector,
        match_threshold: 0.1,
        match_count: 6,
        filter_type: "human_course",
        target_pillar: pathRecord.primary_pillar || null
      })

      if (courseError) {
        verifiedCourses = []
      } else if (courses && Array.isArray(courses)) {
        verifiedCourses = courses
      } else {
        verifiedCourses = []
      }

    } catch (err) {
      // Silently continue - matches will be empty arrays
    }

    // =========================================================
    // ðŸ’¾ SAVE MATCHES TO PATH RECORD
    // =========================================================
    const { error: updateError } = await supabase
      .from("upgrade_paths")
      .update({
        ai_tools: verifiedTools,
        human_courses: verifiedCourses,
      })
      .eq("id", pathId)

    if (updateError) {
      // Continue execution - matches will still be sent to n8n
    }

    // =========================================================
    // ðŸ’¾ INSERT INTO path_resources TABLE
    // =========================================================
    // Define impact weights for HVQ calculation (must match path-resources.ts)
    const weights: Record<string, number> = {
      suggested: 0.5,
      added_free: 1.0,
      added_enrolled: 1.0,
      added_paid: 1.5,
      added_completed: 1.5,
      wishlisted: 0.2,
      removed: 0
    }

    // Insert ai_tools into path_resources with status 'suggested'
    if (verifiedTools.length > 0) {
      const toolInserts = verifiedTools
        .map((tool: any) => ({
          path_id: pathId,
          resource_id: tool.id,
          user_id: user.id, // Required for RLS
          status: "suggested",
          impact_weight: weights["suggested"] || 0.5,
          created_at: new Date().toISOString(),
          updated_at: new Date().toISOString()
        }))
        .filter((item: any) => item.resource_id) // Only include items with resource_id

      if (toolInserts.length > 0) {
        const { error: toolsError } = await supabase
          .from("path_resources")
          .upsert(toolInserts, {
            onConflict: "path_id,resource_id",
            ignoreDuplicates: false
          })

        if (toolsError) {
          // Continue - tools may already exist
        }
      }
    }

    // Insert human_courses into path_resources with status 'suggested'
    if (verifiedCourses.length > 0) {
      const courseInserts = verifiedCourses
        .map((course: any) => ({
          path_id: pathId,
          resource_id: course.id,
          user_id: user.id, // Required for RLS
          status: "suggested",
          impact_weight: weights["suggested"] || 0.5,
          created_at: new Date().toISOString(),
          updated_at: new Date().toISOString()
        }))
        .filter((item: any) => item.resource_id) // Only include items with resource_id

      if (courseInserts.length > 0) {
        const { error: coursesError } = await supabase
          .from("path_resources")
          .upsert(courseInserts, {
            onConflict: "path_id,resource_id",
            ignoreDuplicates: false
          })

        if (coursesError) {
          // Continue - courses may already exist
        }
      }
    }

    // =========================================================
    // ðŸ“Š INITIAL HVQ SCORE
    // =========================================================
    const initialScore = await calculatePathHVQScore(pathId)

    if (initialScore !== null) {
      await supabase
        .from("upgrade_paths")
        .update({ current_hvq_score: initialScore })
        .eq("id", pathId)
    }

    // =========================================================
    // ðŸš€ SEND TO N8N
    // =========================================================
    const webhookUrl = process.env.NEXT_PUBLIC_N8N_WEBHOOK

    if (!webhookUrl) {
      return { success: false, error: "Configuration Error" }
    }

    const response = await fetch(webhookUrl, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        user_id: user.id,
        path_id: pathId,
        ...data,
        verified_matches: {
          tools: verifiedTools,
          courses: verifiedCourses
        }
      }),
    })

    if (!response.ok) {
      return { success: false, error: "AI Agent refused connection" }
    }

    revalidatePath("/")
    // Return only pathId - slug will be ready after n8n processes
    // Frontend will poll for the final slug
    return { success: true, pathId }

  } catch (error) {
    return { success: false, error: "An unexpected error occurred" }
  }
}